# -*- coding: utf-8 -*-
"""Image Classification Project -Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_0MPGb4805l0nnPUjGcZK67Az6CA3v7Q
"""

from google.colab import files
files.upload()  # Upload kaggle.json file

# Create the .kaggle folder and move the kaggle.json to the right place
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# Install Kaggle API
!pip install -q kaggle

# Download the dataset from Kaggle
!kaggle datasets download -d abhikjha/imdb-wiki-faces-dataset

# Unzip the dataset
!unzip imdb-wiki-faces-dataset.zip -d imdb_wiki_faces

# Install necessary libraries
!pip install mtcnn opencv-python

import os
import cv2
import numpy as np
from mtcnn import MTCNN
from PIL import Image

# Initialize MTCNN for face detection
detector = MTCNN()

# Path to the dataset folder
dataset_path = '/content/imdb_wiki_faces/'

def preprocess_image(image_path):
    """
    Preprocesses an image: face detection, cropping, resizing to 224x224.
    """
    try:
        # Open the image
        image = Image.open(image_path)
        image = np.array(image)

        # Detect faces using MTCNN
        faces = detector.detect_faces(image)
        if faces:
            x, y, width, height = faces[0]['box']
            face = image[y:y+height, x:x+width]
            # Resize to 224x224 for the models
            face_resized = cv2.resize(face, (224, 224))
            # Normalize pixel values to range [0, 1]
            face_normalized = face_resized / 255.0
            return face_normalized
        else:
            print(f"No face detected in image: {image_path}")
            return None
    except Exception as e:
        print(f"Error processing image {image_path}: {e}")
        return None

image_paths = []  # List to hold the image paths
ages = []  # List to hold the calculated ages

# Walk through the dataset directory and collect image paths and their calculated ages
for root, dirs, files in os.walk(dataset_path):
    for file in files:
        if file.endswith(".jpg") or file.endswith(".png"):
            image_path = os.path.join(root, file)
            image_paths.append(image_path)

            try:
                # Extract birth date and photo year from the filename
                parts = file.split('_')
                birth_year = int(parts[2].split('-')[0])  # Extract the year from the birth date
                photo_year = int(parts[3].split('.')[0])  # Extract the photo year

                # Calculate the age
                age = photo_year - birth_year

                # Add the age to the list
                ages.append(age)
            except (ValueError, IndexError) as e:
                print(f"Could not extract age from filename: {file}. Error: {e}")
                continue  # Skip to the next file

from sklearn.model_selection import train_test_split

# Split the data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(image_paths, ages, test_size=0.2, random_state=42)

import torch

# Preprocess batch function to handle image paths and labels
def preprocess_batch(image_paths, ages):
    batch_images = []
    batch_labels = []
    for img_path, age in zip(image_paths, ages):
        img = preprocess_image(img_path)  # Preprocess image (face detection, resizing)
        if img is not None:
            batch_images.append(img)
            batch_labels.append(1 if age >= 18 else 0)  # Binary classification label
    return torch.tensor(batch_images, dtype=torch.float32).permute(0, 3, 1, 2), torch.tensor(batch_labels, dtype=torch.float32)

import torch.nn as nn
import torchvision.models as models

# Load the ResNext-50 model pre-trained on ImageNet
resnext_model = models.resnext50_32x4d(pretrained=True)

# Modify the last layer for binary classification (eligible or not)
num_features = resnext_model.fc.in_features
resnext_model.fc = nn.Sequential(
    nn.Linear(num_features, 128),
    nn.ReLU(),
    nn.Dropout(0.5),
    nn.Linear(128, 1),  # Output layer for binary classification
    nn.Sigmoid()  # Sigmoid for binary output
)

# Move the model to GPU if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
resnext_model.to(device)

# Training parameters
epochs = 100
batch_size = 8
optimizer = torch.optim.Adam(resnext_model.parameters(), lr=0.001)
criterion = nn.BCELoss()

# Training loop
for epoch in range(epochs):
    resnext_model.train()  # Set the model to training mode
    running_loss = 0.0

    # Shuffle the training data for each epoch
    shuffled_indices = torch.randperm(len(X_train))
    X_train = [X_train[i] for i in shuffled_indices]
    y_train = [y_train[i] for i in shuffled_indices]

    # Process each batch of data
    for i in range(0, len(X_train), batch_size):
        batch_X, batch_y = preprocess_batch(X_train[i:i+batch_size], y_train[i:i+batch_size])
        batch_X, batch_y = batch_X.to(device), batch_y.to(device)

        optimizer.zero_grad()
        outputs = resnext_model(batch_X)
        loss = criterion(outputs.squeeze(), batch_y)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

    print(f'Epoch {epoch+1}/{epochs}, Training Loss: {running_loss/len(X_train)}')

    # Validation phase
    resnext_model.eval()  # Set the model to evaluation mode
    val_loss = 0.0
    correct = 0
    total = 0

    with torch.no_grad():
        for i in range(0, len(X_val), batch_size):
            batch_X, batch_y = preprocess_batch(X_val[i:i+batch_size], y_val[i:i+batch_size])
            batch_X, batch_y = batch_X.to(device), batch_y.to(device)

            outputs = resnext_model(batch_X)
            loss = criterion(outputs.squeeze(), batch_y)
            val_loss += loss.item()

            # Calculate accuracy
            predictions = (outputs.squeeze() > 0.5).float()
            correct += (predictions == batch_y).sum().item()
            total += batch_y.size(0)

    print(f'Epoch {epoch+1}/{epochs}, Validation Loss: {val_loss/len(X_val)}, Validation Accuracy: {correct/total * 100:.2f}%')

# Save the ResNext-50 model
torch.save(resnext_model.state_dict(), 'resnext_model.pth')